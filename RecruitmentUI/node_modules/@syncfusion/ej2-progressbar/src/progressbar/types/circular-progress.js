import { ProgressAnimation } from '../utils/progress-animation';
import { PathOption, getElement } from '@syncfusion/ej2-svg-base';
import { stringToNumber, getPathArc } from '../utils/helper';
import { Segment } from './segment-progress';
/**
 * Progressbar of type circular
 */
var Circular = /** @class */ (function () {
    function Circular(progress) {
        this.segment = new Segment();
        this.animation = new ProgressAnimation();
        this.progress = progress;
    }
    /** To render the circular track */
    Circular.prototype.renderCircularTrack = function () {
        var progress = this.progress;
        var centerX;
        var centerY;
        var size;
        var radius;
        var startAngle;
        var endAngle;
        var circularTrack;
        var circularPath;
        var trackThickness;
        var option;
        var fill;
        var strokeWidth;
        var circularTrackGroup = progress.renderer.createGroup({ 'id': progress.element.id + '_CircularTrackGroup' });
        startAngle = progress.startAngle;
        progress.totalAngle = (progress.endAngle - progress.startAngle) % 360;
        progress.totalAngle = (progress.totalAngle <= 0 ? (360 + progress.totalAngle) : progress.totalAngle);
        progress.totalAngle -= (progress.totalAngle === 360) ? 0.01 : 0;
        endAngle = (progress.startAngle + ((progress.enableRtl) ? -progress.totalAngle : +progress.totalAngle)) % 360;
        centerX = progress.progressRect.x + (progress.progressRect.width / 2);
        centerY = progress.progressRect.y + (progress.progressRect.height / 2);
        trackThickness = Math.max(progress.trackThickness, progress.progressThickness) ||
            Math.max(progress.themeStyle.circularProgressThickness, progress.themeStyle.circularTrackThickness);
        size = (Math.min(progress.progressRect.height, progress.progressRect.width) / 2) - trackThickness / 2;
        radius = stringToNumber(progress.radius, size);
        radius = (radius === null) ? 0 : radius;
        fill = (progress.enablePieProgress) ? (progress.argsData.trackColor || progress.themeStyle.circularTrackColor) : 'none';
        strokeWidth = (progress.enablePieProgress) ? 0 : (progress.trackThickness || progress.themeStyle.circularTrackThickness);
        circularPath = getPathArc(centerX, centerY, radius, startAngle, endAngle, progress.enableRtl, progress.enablePieProgress);
        option = new PathOption(progress.element.id + '_Circulartrack', fill, strokeWidth, (progress.argsData.trackColor || progress.themeStyle.circularTrackColor), progress.themeStyle.trackOpacity, '0', circularPath);
        circularTrack = progress.renderer.drawPath(option);
        progress.trackwidth = circularTrack.getTotalLength();
        if (progress.segmentCount > 1 && !progress.enablePieProgress) {
            progress.segmentSize = progress.calculateSegmentSize(progress.trackwidth, (progress.trackThickness || progress.themeStyle.linearTrackThickness));
            circularTrack.setAttribute('stroke-dasharray', progress.segmentSize);
        }
        if (progress.cornerRadius === 'Round' && !progress.enablePieProgress) {
            circularTrack.setAttribute('stroke-linecap', 'round');
        }
        circularTrackGroup.appendChild(circularTrack);
        progress.svgObject.appendChild(circularTrackGroup);
    };
    /** To render the circular progress */
    Circular.prototype.renderCircularProgress = function (previousStart, previousEnd, refresh) {
        var progress = this.progress;
        var centerX;
        var centerY;
        var size;
        var endAngle;
        var radius;
        var startAngle = progress.startAngle;
        var previousPath;
        progress.progressStartAngle = startAngle;
        var circularPath;
        var progressEnd;
        var circularProgress;
        var option;
        var progressThickness;
        var linearClipPath;
        var rDiff;
        var progressSegment;
        var circularProgressGroup;
        var fill;
        var strokeWidth;
        centerX = progress.progressRect.x + (progress.progressRect.width / 2);
        centerY = progress.progressRect.y + (progress.progressRect.height / 2);
        progressThickness = Math.max(progress.trackThickness, progress.progressThickness) ||
            Math.max(progress.themeStyle.circularProgressThickness, progress.themeStyle.circularTrackThickness);
        size = (Math.min(progress.progressRect.height, progress.progressRect.width) / 2) - progressThickness / 2;
        radius = stringToNumber(progress.innerRadius, size);
        radius = (radius === null) ? 0 : radius;
        if (progress.secondaryProgress !== null && !progress.isIndeterminate) {
            this.renderCircularBuffer(progress, centerX, centerY, radius, startAngle);
        }
        if (progress.argsData.value !== null) {
            circularProgressGroup = progress.renderer.createGroup({ 'id': progress.element.id + '_CircularProgressGroup' });
            progressEnd = progress.calculateProgressRange(progress.minimum, progress.maximum, progress.argsData.value);
            if (progress.segmentColor.length !== 0 && !progress.isIndeterminate && !progress.enablePieProgress) {
                circularProgress = this.segment.createCircularSegment(progress, '_CircularProgressSegment', centerX, centerY, radius, progress.argsData.value, progress.themeStyle.progressOpacity, (progress.progressThickness || progress.themeStyle.circularProgressThickness));
            }
            else {
                progress.annotationEnd = progressEnd;
                endAngle = ((progress.isIndeterminate) ? (progress.startAngle + ((progress.enableRtl) ? -progress.totalAngle : +progress.totalAngle)) % 360 : progressEnd);
                circularPath = getPathArc(centerX, centerY, radius, startAngle, endAngle, progress.enableRtl, progress.enablePieProgress);
                fill = (progress.enablePieProgress) ?
                    (progress.argsData.progressColor || progress.themeStyle.circularProgressColor) : 'none';
                strokeWidth = (progress.enablePieProgress) ? 0 :
                    (progress.progressThickness || progress.themeStyle.circularProgressThickness);
                option = new PathOption(progress.element.id + '_Circularprogress', fill, strokeWidth, (progress.argsData.progressColor || progress.themeStyle.circularProgressColor), progress.themeStyle.progressOpacity, '0', circularPath);
                if (!refresh) {
                    circularProgress = progress.renderer.drawPath(option);
                }
                else {
                    circularProgress = getElement(progress.element.id + '_Circularprogress');
                    previousPath = circularProgress.getAttribute('d');
                    circularProgress.setAttribute('d', circularPath);
                    circularProgress.setAttribute('stroke', progress.argsData.progressColor || progress.themeStyle.circularProgressColor);
                }
                if (progress.segmentCount > 1 && !progress.enablePieProgress) {
                    rDiff = parseInt(progress.radius, 10) - parseInt(progress.innerRadius, 10);
                    if (rDiff !== 0) {
                        progressSegment = progress.trackwidth + ((rDiff < 0) ? (progress.trackwidth * Math.abs(rDiff)) / parseInt(progress.radius, 10) :
                            -(progress.trackwidth * Math.abs(rDiff)) / parseInt(progress.radius, 10));
                        progress.segmentSize = progress.calculateSegmentSize(progressSegment, (progress.progressThickness || progress.themeStyle.circularProgressThickness));
                    }
                    circularProgress.setAttribute('stroke-dasharray', progress.segmentSize);
                }
                if (progress.cornerRadius === 'Round') {
                    circularProgress.setAttribute('stroke-linecap', 'round');
                }
            }
            progress.progressEndAngle = endAngle;
            if (!refresh) {
                circularProgressGroup.appendChild(circularProgress);
                progress.svgObject.appendChild(circularProgressGroup);
            }
            if (progress.animation.enable && !progress.isIndeterminate) {
                var circulardelay = (progress.secondaryProgress !== null) ? 300 : progress.animation.delay;
                linearClipPath = progress.createClipPath(progress.clipPath, null, refresh ? previousPath : '', null, refresh);
                circularProgressGroup.appendChild(progress.clipPath);
                circularProgress.setAttribute('style', 'clip-path:url(#' + progress.element.id + '_clippath)');
                this.animation.doCircularAnimation(centerX, centerY, radius, startAngle, progressEnd, linearClipPath, progress, (progress.progressThickness || progress.themeStyle.circularProgressThickness), circulardelay, refresh ? previousEnd : null);
            }
            if (progress.isIndeterminate) {
                linearClipPath = progress.createClipPath(progress.clipPath, null, refresh ? previousPath : '', null, refresh);
                circularProgressGroup.appendChild(progress.clipPath);
                circularProgress.setAttribute('style', 'clip-path:url(#' + progress.element.id + '_clippath)');
                this.animation.doCircularIndeterminate(linearClipPath, progress, startAngle, progressEnd, centerX, centerY, radius, (progress.progressThickness || progress.themeStyle.circularProgressThickness));
            }
            progress.svgObject.appendChild(circularProgressGroup);
        }
    };
    /** To render the circular buffer */
    Circular.prototype.renderCircularBuffer = function (progress, centerX, centerY, radius, startAngle) {
        var bufferClipPath;
        var bufferEnd;
        var circularBuffer;
        var radiusDiff;
        var circularBufferGroup;
        var circularPath;
        var option;
        var progressSegment;
        var fill;
        var strokeWidth;
        circularBufferGroup = progress.renderer.createGroup({ 'id': progress.element.id + '_ CircularBufferGroup' });
        bufferEnd = progress.calculateProgressRange(progress.minimum, progress.maximum, progress.secondaryProgress);
        if (progress.segmentColor.length !== 0 && !progress.isIndeterminate && !progress.enablePieProgress) {
            circularBuffer = this.segment.createCircularSegment(progress, '_CircularBufferSegment', centerX, centerY, radius, progress.secondaryProgress, progress.themeStyle.bufferOpacity, (progress.progressThickness || progress.themeStyle.circularProgressThickness));
        }
        else {
            circularPath = getPathArc(centerX, centerY, radius, startAngle, bufferEnd, progress.enableRtl, progress.enablePieProgress);
            fill = (progress.enablePieProgress) ? (progress.argsData.progressColor || progress.themeStyle.circularProgressColor) : 'none';
            strokeWidth = (progress.enablePieProgress) ? 0 : (progress.progressThickness || progress.themeStyle.circularProgressThickness);
            option = new PathOption(progress.element.id + '_Circularbuffer', fill, strokeWidth, (progress.argsData.progressColor || progress.themeStyle.circularProgressColor), progress.themeStyle.bufferOpacity, '0', circularPath);
            circularBuffer = progress.renderer.drawPath(option);
            if (progress.segmentCount > 1 && !progress.enablePieProgress) {
                radiusDiff = parseInt(progress.radius, 10) - parseInt(progress.innerRadius, 10);
                if (radiusDiff !== 0) {
                    progressSegment = progress.trackwidth + ((radiusDiff < 0) ? (progress.trackwidth * Math.abs(radiusDiff)) / parseInt(progress.radius, 10) :
                        -(progress.trackwidth * Math.abs(radiusDiff)) / parseInt(progress.radius, 10));
                    progress.segmentSize = progress.calculateSegmentSize(progressSegment, (progress.progressThickness || progress.themeStyle.circularProgressThickness));
                }
                circularBuffer.setAttribute('stroke-dasharray', progress.segmentSize);
            }
            if (progress.cornerRadius === 'Round') {
                circularBuffer.setAttribute('stroke-linecap', 'round');
            }
        }
        circularBufferGroup.appendChild(circularBuffer);
        if (progress.animation.enable) {
            bufferClipPath = progress.createClipPath(progress.bufferClipPath, null, '', null, false);
            circularBufferGroup.appendChild(progress.bufferClipPath);
            circularBuffer.setAttribute('style', 'clip-path:url(#' + progress.element.id + '_clippathBuffer)');
            this.animation.doCircularAnimation(centerX, centerY, radius, startAngle, bufferEnd, bufferClipPath, progress, (progress.progressThickness || progress.themeStyle.circularProgressThickness), progress.animation.delay, null);
        }
        progress.svgObject.appendChild(circularBufferGroup);
    };
    return Circular;
}());
export { Circular };
