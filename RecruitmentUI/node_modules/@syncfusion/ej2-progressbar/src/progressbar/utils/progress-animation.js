import { Animation } from '@syncfusion/ej2-base';
import { effect, getPathArc } from '../utils/helper';
import { lineCapRadius, completeAngle } from '../model/constant';
/**
 * Animation for progress bar
 */
var ProgressAnimation = /** @class */ (function () {
    function ProgressAnimation() {
    }
    /** Linear Animation */
    ProgressAnimation.prototype.doLinearAnimation = function (element, progress, delay, start) {
        var animation = new Animation({});
        var linearPath = element;
        var width = linearPath.getAttribute('width');
        var x = linearPath.getAttribute('x');
        var value = 0;
        var rtlX = parseInt(x, 10) - parseInt(width, 10);
        linearPath.style.visibility = 'hidden';
        animation.animate(linearPath, {
            duration: progress.animation.duration,
            delay: delay,
            progress: function (args) {
                if (progress.enableRtl) {
                    if (args.timeStamp >= args.delay) {
                        linearPath.style.visibility = 'visible';
                        value = effect(args.timeStamp, parseInt(x, 10), parseInt(width, 10), args.duration, progress.enableRtl);
                        linearPath.setAttribute('x', value.toString());
                    }
                }
                else {
                    if (args.timeStamp >= args.delay) {
                        linearPath.style.visibility = 'visible';
                        value = effect(args.timeStamp, start, parseInt(width, 10), args.duration, progress.enableRtl);
                        linearPath.setAttribute('width', value.toString());
                    }
                }
            },
            end: function (model) {
                if (progress.enableRtl) {
                    linearPath.setAttribute('x', rtlX.toString());
                }
                else {
                    linearPath.setAttribute('width', width);
                }
                progress.trigger('animationComplete', {
                    value: progress.value, trackColor: progress.trackColor,
                    progressColor: progress.progressColor
                });
            }
        });
    };
    /** Linear Indeterminate */
    ProgressAnimation.prototype.doLinearIndeterminate = function (element, progress) {
        var _this = this;
        var animation = new Animation({});
        var linearPath = element;
        var x = linearPath.getAttribute('x');
        var width = linearPath.getAttribute('width');
        var value = 0;
        var start = -(parseInt(width, 10));
        var end = (progress.progressRect.x + progress.progressRect.width) + parseInt(width, 10);
        animation.animate(linearPath, {
            duration: 2000,
            delay: 0,
            progress: function (args) {
                if (progress.enableRtl) {
                    value = effect(args.timeStamp, parseInt(x, 10), end, args.duration, progress.enableRtl);
                    linearPath.setAttribute('x', value.toString());
                }
                else {
                    value = effect(args.timeStamp, start, end, args.duration, progress.enableRtl);
                    linearPath.setAttribute('x', value.toString());
                }
            },
            end: function (model) {
                if (progress.enableRtl) {
                    linearPath.setAttribute('x', x.toString());
                }
                else {
                    linearPath.setAttribute('x', start.toString());
                }
                _this.doLinearIndeterminate(element, progress);
            }
        });
    };
    /** Circular animation */
    ProgressAnimation.prototype.doCircularAnimation = function (x, y, radius, start, progressEnd, value, element, progress, thickness, delay, startValue) {
        var animation = new Animation({});
        var circularPath = element;
        var pathRadius = radius + (thickness / 2);
        var end = 0;
        var totalEnd;
        totalEnd = ((value - progress.minimum) / (progress.maximum - progress.minimum)) * progress.totalAngle;
        totalEnd = (value < progress.minimum || value > progress.maximum) ? 0 : totalEnd;
        start += (progress.cornerRadius === 'Round' && totalEnd !== completeAngle && totalEnd !== 0) ?
            ((progress.enableRtl) ? (lineCapRadius / 2) * thickness : -(lineCapRadius / 2) * thickness) : 0;
        totalEnd += (progress.cornerRadius === 'Round' && totalEnd !== completeAngle && totalEnd !== 0) ?
            (lineCapRadius / 2) * thickness : 0;
        progressEnd += (progress.cornerRadius === 'Round' && totalEnd !== completeAngle && totalEnd !== 0) ?
            ((progress.enableRtl) ? -(lineCapRadius / 2) * thickness : (lineCapRadius / 2) * thickness) : 0;
        circularPath.setAttribute('visibility', 'Hidden');
        animation.animate(circularPath, {
            duration: progress.animation.duration,
            delay: delay,
            progress: function (args) {
                if (args.timeStamp >= args.delay) {
                    circularPath.setAttribute('visibility', 'visible');
                    end = effect(args.timeStamp, startValue | start, totalEnd, args.duration, progress.enableRtl);
                    circularPath.setAttribute('d', getPathArc(x, y, pathRadius, start, end % 360, progress.enableRtl, true));
                }
            },
            end: function (model) {
                circularPath.setAttribute('d', getPathArc(x, y, pathRadius, start, progressEnd, progress.enableRtl, true));
                progress.trigger('animationComplete', {
                    value: progress.value, trackColor: progress.trackColor,
                    progressColor: progress.progressColor
                });
            }
        });
    };
    /** Circular indeterminate */
    ProgressAnimation.prototype.doCircularIndeterminate = function (circularProgress, progress, start, end, x, y, radius, thickness) {
        var _this = this;
        var animation = new Animation({});
        var pathRadius = radius + (thickness / 2);
        animation.animate(circularProgress, {
            duration: 2000,
            delay: 0,
            progress: function (args) {
                start += (progress.enableRtl) ? -5 : 5;
                end += (progress.enableRtl) ? -5 : 5;
                circularProgress.setAttribute('d', getPathArc(x, y, pathRadius, start % 360, end % 360, progress.enableRtl, true));
            },
            end: function (model) {
                _this.doCircularIndeterminate(circularProgress, progress, start, end, x, y, radius, thickness);
            }
        });
    };
    /** To do the label animation for progress bar */
    ProgressAnimation.prototype.doLabelAnimation = function (labelPath, start, end, progress, delay) {
        var animation = new Animation({});
        var text = labelPath.innerHTML;
        var value = 0;
        var valueChanged = 0;
        var percentage = 100;
        labelPath.setAttribute('visibility', 'Hidden');
        animation.animate(labelPath, {
            duration: progress.animation.duration,
            delay: delay,
            progress: function (args) {
                if (progress.type === 'Linear') {
                    if (args.timeStamp >= args.delay) {
                        labelPath.setAttribute('visibility', 'visible');
                        value = effect(args.timeStamp, start, end, args.duration, false);
                        valueChanged = parseInt(((value / progress.progressRect.width) * percentage).toString(), 10);
                        labelPath.innerHTML = valueChanged.toString() + '%';
                    }
                }
                else if (progress.type === 'Circular') {
                    labelPath.setAttribute('visibility', 'visible');
                    value = effect(args.timeStamp, start, end, args.duration, false);
                    valueChanged = parseInt((((value - start) / progress.totalAngle) * percentage).toString(), 10);
                    labelPath.innerHTML = valueChanged.toString() + '%';
                }
            },
            end: function (model) {
                labelPath.innerHTML = text;
            }
        });
    };
    /** To do the annotation animation for circular progress bar */
    ProgressAnimation.prototype.doAnnotationAnimation = function (circularPath, progress) {
        var animation = new Animation({});
        var value = 0;
        var percentage = 100;
        var isAnnotation = progress.annotations.length > 0;
        var annotatElementChanged;
        var firstAnnotatElement;
        var start = progress.startAngle;
        var totalAngle = progress.totalAngle;
        var totalEnd;
        var annotateValueChanged;
        var annotateValue;
        if (isAnnotation && progress.progressAnnotationModule) {
            firstAnnotatElement = document.getElementById(progress.element.id + 'Annotation0').children[0];
            if (firstAnnotatElement && firstAnnotatElement.children[0]) {
                if (firstAnnotatElement.children[0].tagName === 'SPAN') {
                    annotatElementChanged = firstAnnotatElement.children[0];
                }
            }
        }
        totalEnd = ((progress.value - progress.minimum) / (progress.maximum - progress.minimum)) * progress.totalAngle;
        totalEnd = (progress.value < progress.minimum || progress.value > progress.maximum) ? 0 : totalEnd;
        annotateValue = ((progress.value - progress.minimum) / (progress.maximum - progress.minimum)) * percentage;
        annotateValue = (progress.value < progress.minimum || progress.value > progress.maximum) ? 0 : Math.round(annotateValue);
        animation.animate(circularPath, {
            duration: progress.animation.duration,
            delay: progress.animation.delay,
            progress: function (args) {
                if (isAnnotation && annotatElementChanged) {
                    value = effect(args.timeStamp, start, totalEnd, args.duration, false);
                    annotateValueChanged = parseInt((((value - start) / totalAngle) * percentage).toString(), 10);
                    annotatElementChanged.innerHTML = annotateValueChanged ? annotateValueChanged.toString() + '%' : '';
                }
            },
            end: function (model) {
                annotatElementChanged.innerHTML = annotateValue + '%';
            }
        });
    };
    return ProgressAnimation;
}());
export { ProgressAnimation };
